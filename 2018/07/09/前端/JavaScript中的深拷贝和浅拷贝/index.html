<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>JavaScript中的深拷贝和浅拷贝 | 你总是这样轻言放弃的话，无论多久你都只会原地踏步。</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JavaScript中的深拷贝和浅拷贝</h1><a id="logo" href="/.">你总是这样轻言放弃的话，无论多久你都只会原地踏步。</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JavaScript中的深拷贝和浅拷贝</h1><div class="post-meta">Jul 9, 2018<span> | </span><span class="category"><a href="/categories/前端之巅/">前端之巅</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2018/07/09/前端/JavaScript中的深拷贝和浅拷贝/" href="/2018/07/09/前端/JavaScript中的深拷贝和浅拷贝/#comments" class="ds-thread-count"></a><div class="post-content"><h3 id="在说深拷贝与浅拷贝前，我们先看两个简单的案例："><a href="#在说深拷贝与浅拷贝前，我们先看两个简单的案例：" class="headerlink" title="在说深拷贝与浅拷贝前，我们先看两个简单的案例："></a>在说深拷贝与浅拷贝前，我们先看两个简单的案例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//案例1</span><br><span class="line">var num1 = 1, num2 = num1;</span><br><span class="line">console.log(num1) //1</span><br><span class="line">console.log(num2) //1</span><br><span class="line"></span><br><span class="line">num2 = 2; //修改num2</span><br><span class="line">console.log(num1) //1</span><br><span class="line">console.log(num2) //2</span><br><span class="line"></span><br><span class="line">//案例2</span><br><span class="line">var obj1 = &#123;x: 1, y: 2&#125;, obj2 = obj1;</span><br><span class="line">console.log(obj1) //&#123;x: 1, y: 2&#125;</span><br><span class="line">console.log(obj2) //&#123;x: 1, y: 2&#125;</span><br><span class="line"></span><br><span class="line">obj2.x = 2; //修改obj2.x</span><br><span class="line">console.log(obj1) //&#123;x: 2, y: 2&#125;</span><br><span class="line">console.log(obj2) //&#123;x: 2, y: 2&#125;</span><br></pre></td></tr></table></figure>
<p>按照常规思维，obj1应该和num1一样，不会因为另外一个值的改变而改变，而这里的obj1 却随着obj2的改变而改变了。同样是变量，为什么表现不一样呢？这就要引入JS中基本类型和引用类型的概念了。</p>
<h3 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是那些保存在栈内存中的简单数据段，即这种值完全保存在内存中的一个位置。而引用类型值是指那些保存堆内存中的对象，意思是变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，该位置保存对象。</span><br></pre></td></tr></table></figure>
<p>打个比方，基本类型和引用类型在赋值上的区别可以按“连锁店”和“单店”来理解：基本类型赋值等于在一个新的地方安装连锁店的规范标准新开一个分店，新开的店与其他旧店互不相关，各自运营；而引用类型赋值相当于一个店有两把钥匙，交给两个老板同时管理，两个老板的行为都有可能对一间店的运营造成影响。</p>
<p>上面清晰明了的介绍了基本类型和引用类型的定义和区别。目前基本类型有：Boolean、Null、Undefined、Number、String、Symbol，引用类型有：Object、Array、Function。之所以说“目前”，因为Symbol就是ES6才出来的，之后也可能会有新的类型出来。</p>
<p>再回到前面的案例，案例1中的值为基本类型，案例2中的值为引用类型。案例2中的赋值就是典型的浅拷贝，并且深拷贝与浅拷贝的概念只存在于引用类型。</p>
<h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><p>既然已经知道了深拷贝与浅拷贝的来由，那么该如何实现深拷贝？我们先分别看看Array和Object自有方法是否支持：</p>
<p>Array</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1, 2], arr2 = arr1.slice();</span><br><span class="line">console.log(arr1); //[1, 2]</span><br><span class="line">console.log(arr2); //[1, 2]</span><br><span class="line"></span><br><span class="line">arr2[0] = 3; //修改arr2</span><br><span class="line">console.log(arr1); //[1, 2]</span><br><span class="line">console.log(arr2); //[3, 2]</span><br></pre></td></tr></table></figure>
<h3 id="此时，arr2的修改并没有影响到arr1，看来深拷贝的实现并没有那么难嘛。我们把arr1改成二维数组再来看看："><a href="#此时，arr2的修改并没有影响到arr1，看来深拷贝的实现并没有那么难嘛。我们把arr1改成二维数组再来看看：" class="headerlink" title="此时，arr2的修改并没有影响到arr1，看来深拷贝的实现并没有那么难嘛。我们把arr1改成二维数组再来看看："></a>此时，arr2的修改并没有影响到arr1，看来深拷贝的实现并没有那么难嘛。我们把arr1改成二维数组再来看看：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1, 2, [3, 4]], arr2 = arr1.slice();</span><br><span class="line">console.log(arr1); //[1, 2, [3, 4]]</span><br><span class="line">console.log(arr2); //[1, 2, [3, 4]]</span><br><span class="line"></span><br><span class="line">arr2[2][1] = 5; </span><br><span class="line">console.log(arr1); //[1, 2, [3, 5]]</span><br><span class="line">console.log(arr2); //[1, 2, [3, 5]]</span><br></pre></td></tr></table></figure>
<p>咦，arr2又改变了arr1，看来slice()只能实现一维数组的深拷贝。</p>
<p>具备同等特性的还有：concat、Array.from() 。</p>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>1.Object.assign()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;x: 1, y: 2&#125;, obj2 = Object.assign(&#123;&#125;, obj1);</span><br><span class="line">console.log(obj1) //&#123;x: 1, y: 2&#125;</span><br><span class="line">console.log(obj2) //&#123;x: 1, y: 2&#125;</span><br><span class="line"></span><br><span class="line">obj2.x = 2; //修改obj2.x</span><br><span class="line">console.log(obj1) //&#123;x: 1, y: 2&#125;</span><br><span class="line">console.log(obj2) //&#123;x: 2, y: 2&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">    x: 1, </span><br><span class="line">    y: &#123;</span><br><span class="line">        m: 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = Object.assign(&#123;&#125;, obj1);</span><br><span class="line">console.log(obj1) //&#123;x: 1, y: &#123;m: 1&#125;&#125;</span><br><span class="line">console.log(obj2) //&#123;x: 1, y: &#123;m: 1&#125;&#125;</span><br><span class="line"></span><br><span class="line">obj2.y.m = 2; //修改obj2.y.m</span><br><span class="line">console.log(obj1) //&#123;x: 1, y: &#123;m: 2&#125;&#125;</span><br><span class="line">console.log(obj2) //&#123;x: 2, y: &#123;m: 2&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>经测试，Object.assign()也只能实现一维对象的深拷贝。</p>
<p>2.JSON.parse(JSON.stringify(obj))</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">    x: 1, </span><br><span class="line">    y: &#123;</span><br><span class="line">        m: 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = JSON.parse(JSON.stringify(obj1));</span><br><span class="line">console.log(obj1) //&#123;x: 1, y: &#123;m: 1&#125;&#125;</span><br><span class="line">console.log(obj2) //&#123;x: 1, y: &#123;m: 1&#125;&#125;</span><br><span class="line"></span><br><span class="line">obj2.y.m = 2; //修改obj2.y.m</span><br><span class="line">console.log(obj1) //&#123;x: 1, y: &#123;m: 1&#125;&#125;</span><br><span class="line">console.log(obj2) //&#123;x: 2, y: &#123;m: 2&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>JSON.parse(JSON.stringify(obj)) 看起来很不错，不过MDN文档 的描述有句话写的很清楚：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。</span><br></pre></td></tr></table></figure>
<p>我们再来把obj1改造下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">    x: 1,</span><br><span class="line">    y: undefined,</span><br><span class="line">    z: function add(z1, z2) &#123;</span><br><span class="line">        return z1 + z2</span><br><span class="line">    &#125;,</span><br><span class="line">    a: Symbol(&quot;foo&quot;)</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = JSON.parse(JSON.stringify(obj1));</span><br><span class="line">console.log(obj1) //&#123;x: 1, y: undefined, z: ƒ, a: Symbol(foo)&#125;</span><br><span class="line">console.log(JSON.stringify(obj1)); //&#123;&quot;x&quot;:1&#125;</span><br><span class="line">console.log(obj2) //&#123;x: 1&#125;</span><br></pre></td></tr></table></figure>
<p>发现，在将obj1进行JSON.stringify()序列化的过程中，y、z、a都被忽略了，也就验证了MDN文档的描述。既然这样，那JSON.parse(JSON.stringify(obj))的使用也是有局限性的，不能深拷贝含有undefined、function、symbol值的对象，不过JSON.parse(JSON.stringify(obj))简单粗暴，已经满足90%的使用场景了。</p>
<p>经过验证，我们发现JS 提供的自有方法并不能彻底解决Array、Object的深拷贝问题。只能祭出大杀器：递归</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">    // 创建一个新对象</span><br><span class="line">    let result = &#123;&#125;</span><br><span class="line">    let keys = Object.keys(obj),</span><br><span class="line">        key = null,</span><br><span class="line">        temp = null;</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">        key = keys[i];    </span><br><span class="line">        temp = obj[key];</span><br><span class="line">        // 如果字段的值也是一个对象则递归操作</span><br><span class="line">        if (temp &amp;&amp; typeof temp === &apos;object&apos;) &#123;</span><br><span class="line">            result[key] = deepCopy(temp);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        // 否则直接赋值给新对象</span><br><span class="line">            result[key] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    x: &#123;</span><br><span class="line">        m: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    y: undefined,</span><br><span class="line">    z: function add(z1, z2) &#123;</span><br><span class="line">        return z1 + z2</span><br><span class="line">    &#125;,</span><br><span class="line">    a: Symbol(&quot;foo&quot;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 = deepCopy(obj1);</span><br><span class="line">obj2.x.m = 2;</span><br><span class="line"></span><br><span class="line">console.log(obj1); //&#123;x: &#123;m: 1&#125;, y: undefined, z: ƒ, a: Symbol(foo)&#125;</span><br><span class="line">console.log(obj2); //&#123;x: &#123;m: 2&#125;, y: undefined, z: ƒ, a: Symbol(foo)&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，递归完美的解决了前面遗留的所有问题，我们也可以用第三方库：jquery的$.extend和lodash的_.cloneDeep来解决深拷贝。上面虽然是用Object验证，但对于Array也同样适用，因为Array也是特殊的Object。</p>
<p>到这里，深拷贝问题基本可以告一段落了。但是，还有一个非常特殊的场景：</p>
<h4 id="循环引用拷贝"><a href="#循环引用拷贝" class="headerlink" title="循环引用拷贝"></a>循环引用拷贝</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">    x: 1, </span><br><span class="line">    y: 2</span><br><span class="line">&#125;;</span><br><span class="line">obj1.z = obj1;</span><br><span class="line"></span><br><span class="line">var obj2 = deepCopy(obj1);</span><br></pre></td></tr></table></figure>
<p>此时如果调用刚才的deepCopy函数的话，会陷入一个循环的递归过程，从而导致爆栈。jquery的$.extend也没有解决。解决这个问题也非常简单，只需要判断一个对象的字段是否引用了这个对象或这个对象的任意父级即可，修改一下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(obj, parent = null) &#123;</span><br><span class="line">    // 创建一个新对象</span><br><span class="line">    let result = &#123;&#125;;</span><br><span class="line">    let keys = Object.keys(obj),</span><br><span class="line">        key = null,</span><br><span class="line">        temp= null,</span><br><span class="line">        _parent = parent;</span><br><span class="line">    // 该字段有父级则需要追溯该字段的父级</span><br><span class="line">    while (_parent) &#123;</span><br><span class="line">        // 如果该字段引用了它的父级则为循环引用</span><br><span class="line">        if (_parent.originalParent === obj) &#123;</span><br><span class="line">            // 循环引用直接返回同级的新对象</span><br><span class="line">            return _parent.currentParent;</span><br><span class="line">        &#125;</span><br><span class="line">        _parent = _parent.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">        key = keys[i];</span><br><span class="line">        temp= obj[key];</span><br><span class="line">        // 如果字段的值也是一个对象</span><br><span class="line">        if (temp &amp;&amp; typeof temp=== &apos;object&apos;) &#123;</span><br><span class="line">            // 递归执行深拷贝 将同级的待拷贝对象与新对象传递给 parent 方便追溯循环引用</span><br><span class="line">            result[key] = DeepCopy(temp, &#123;</span><br><span class="line">                originalParent: obj,</span><br><span class="line">                currentParent: result,</span><br><span class="line">                parent: parent</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result[key] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    x: 1, </span><br><span class="line">    y: 2</span><br><span class="line">&#125;;</span><br><span class="line">obj1.z = obj1;</span><br><span class="line"></span><br><span class="line">var obj2 = deepCopy(obj1);</span><br><span class="line">console.log(obj1); //太长了去浏览器试一下吧～ </span><br><span class="line">console.log(obj2); //太长了去浏览器试一下吧～</span><br></pre></td></tr></table></figure>
<p>至此，已完成一个支持循环引用的深拷贝函数。当然，也可以使用lodash的_.cloneDeep噢～。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2018/07/09/前端/JavaScript中的深拷贝和浅拷贝/" data-id="cjjqpo3bh006x00nta68e5zio" class="article-share-link">分享到</a><div class="tags"><a href="/tags/前端/">前端</a></div><div class="post-nav"><a href="/2018/07/17/前端/项目管理/" class="pre">项目管理</a><a href="/2018/06/30/php/el/" class="next">el</a></div><div data-thread-key="2018/07/09/前端/JavaScript中的深拷贝和浅拷贝/" data-title="JavaScript中的深拷贝和浅拷贝" data-url="http://yoursite.com/2018/07/09/前端/JavaScript中的深拷贝和浅拷贝/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2018/07/09/前端/JavaScript中的深拷贝和浅拷贝/" data-title="JavaScript中的深拷贝和浅拷贝" data-url="http://yoursite.com/2018/07/09/前端/JavaScript中的深拷贝和浅拷贝/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a><span class="category-list-count">19</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/laravel/">laravel</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/yii/">yii</a><span class="category-list-count">8</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/composer/">composer</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">node</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/rsa/">rsa</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端之巅/">前端之巅</a><span class="category-list-count">33</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术杂谈/">技术杂谈</a><span class="category-list-count">11</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/linux/" style="font-size: 15px;">linux'</a> <a href="/tags/加密/" style="font-size: 15px;">加密</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/composer/" style="font-size: 15px;">composer</a> <a href="/tags/kong/" style="font-size: 15px;">kong</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/前端之巅/" style="font-size: 15px;">前端之巅</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/elasticsearch/" style="font-size: 15px;">elasticsearch</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/前端/" style="font-size: 15px;">前端</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/07/19/前端/小程序2/">小程序（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/18/前端/小程序1/">小程序（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/17/前端/项目管理/">项目管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/09/前端/JavaScript中的深拷贝和浅拷贝/">JavaScript中的深拷贝和浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/30/php/el/">el</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/25/前端/flow/">flow代码规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/18/前端/async:await/">async/await</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/21/linux/kong/">kong安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/19/node/如何逃离async:await困境/">如何逃离async/await困境</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/13/mysql/mysql1/">MySQL数据库在物联网中的应用及其InnoDB的加锁分析</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">你总是这样轻言放弃的话，无论多久你都只会原地踏步。.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'xiaolinouye'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>